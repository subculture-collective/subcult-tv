package middleware
package middleware

import (































































































































}	}		t.Errorf("GET request: expected status %d, got %d", http.StatusOK, recorder.Code)	if recorder.Code != http.StatusOK {	handler.ServeHTTP(recorder, req)	recorder := httptest.NewRecorder()	req := httptest.NewRequest(http.MethodGet, "/", nil)	// GET request should pass through unchanged	}))		w.WriteHeader(http.StatusOK)	handler := LimitBody(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {func TestLimitBodyMiddleware(t *testing.T) {// TestLimitBodyMiddleware tests the body size limit middleware.}	}		t.Error("expected Retry-After: 60 header")	if recorder.Header().Get("Retry-After") != "60" {	// Check Retry-After header	}		t.Errorf("expected status %d, got %d", http.StatusTooManyRequests, recorder.Code)	if recorder.Code != http.StatusTooManyRequests {	handler.ServeHTTP(recorder, req)	recorder := httptest.NewRecorder()	req.RemoteAddr = "192.168.1.100:12345"	req := httptest.NewRequest(http.MethodGet, "/", nil)	// 3rd request should be rate limited	}		}			t.Errorf("request %d: expected status %d, got %d", i+1, http.StatusOK, recorder.Code)		if recorder.Code != http.StatusOK {		handler.ServeHTTP(recorder, req)		recorder := httptest.NewRecorder()		req.RemoteAddr = "192.168.1.100:12345"		req := httptest.NewRequest(http.MethodGet, "/", nil)	for i := 0; i < 2; i++ {	// First 2 requests should pass	}))		w.WriteHeader(http.StatusOK)	handler := RateLimit(limiter)(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {	limiter := NewRateLimiter(2, time.Minute)func TestRateLimitMiddleware(t *testing.T) {// TestRateLimitMiddleware tests the HTTP middleware wrapper.}	}		t.Error("should be allowed after window reset")	if !limiter.Allow("10.0.0.1") {	// Should be allowed again	time.Sleep(150 * time.Millisecond)	// Wait for window to reset	}		t.Error("should be blocked after limit")	if limiter.Allow("10.0.0.1") {	// Should be blocked	limiter.Allow("10.0.0.1")	limiter.Allow("10.0.0.1")	// Use up the limit	limiter := NewRateLimiter(2, 100*time.Millisecond)	// Use a very short window for testingfunc TestRateLimiterWindowReset(t *testing.T) {// TestRateLimiterWindowReset tests that the rate limit resets after the window.}	}		t.Error("different IP should be allowed")	if !limiter.Allow("192.168.1.2") {	// Different IP should be allowed	}		t.Error("4th request should be blocked")	if limiter.Allow("192.168.1.1") {	// 4th request should be blocked	}		}			t.Errorf("request %d should be allowed", i+1)		if !limiter.Allow("192.168.1.1") {	for i := 0; i < 3; i++ {	// First 3 requests should pass	limiter := NewRateLimiter(3, time.Minute)func TestRateLimiterBasic(t *testing.T) {// TestRateLimiterBasic tests basic rate limiting functionality.}	}		}			t.Errorf("expected %s: %s, got: %s", header, expected, actual)		if actual != expected {		actual := recorder.Header().Get(header)	for header, expected := range expectedHeaders {	}		"Referrer-Policy":        "strict-origin-when-cross-origin",		"X-XSS-Protection":       "1; mode=block",		"X-Content-Type-Options": "nosniff",		"X-Frame-Options":        "DENY",	expectedHeaders := map[string]string{	handler.ServeHTTP(recorder, req)	recorder := httptest.NewRecorder()	req := httptest.NewRequest(http.MethodGet, "/", nil)	}))		w.WriteHeader(http.StatusOK)	handler := SecurityHeaders(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {func TestSecurityHeaders(t *testing.T) {// TestSecurityHeaders tests that all security headers are set correctly.)	"time"	"testing"	"net/http/httptest"	"net/http"
